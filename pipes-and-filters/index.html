<h1 id="pipes-and-filters-design-pattern">Pipes-And-Filters Design Pattern</h1>
<p>In many enterprise integration scenarios, a single event triggers a sequence of processing steps/stages. Each performing a specific function.</p>
<p>For example, lets assume you have requirement to encode files in a directory structure and create an output file.<br>This can be achieved by using Pipes-and-Filters architecture style to divide a larger processing task into sequence of smaller tasks - running independently connected to each other by channels ( pipes ).</p>
<p>To be able to demonstrate this scenario, this example create a very simple pipe loading file and processing it.<br>It can be extended to run in parallel to improve performance.</p>
<h4 id="design-pattern-benefits">Design Pattern Benefits</h4>
<p>There are few obvious benefits by using this architectural style listed below:</p>
<ol>
<li>Divide and conquer : The seperate processes can be independently designed</li>
<li>Increase cohesion : The processes have functional cohesion</li>
<li>Reduce coupling : The processes have only one input and one output</li>
<li>Increase abstraction : The pipeline components are often good abstractions, hiding their internal details.</li>
<li>Increase reusability : The processes can often be used in many different contexts</li>
<li>Increase reuse : It is often possible to find reusable components to insert into a pipeline</li>
<li>Design for flexibility : There are several ways in which the system is flexible</li>
<li>Design for testability : It is normally easy to test the individual processes</li>
<li>Design defensivily : You regorously check the inputs of each component, or else you can use design by contract</li>
</ol>
<h4 id="class-diagram">Class Diagram</h4>
<p><img src="pipes-class-diag.png?raw=true" alt="Alt text" title="Pipes-And-Filters Pattern"></p>
